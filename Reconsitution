代码重构一书笔记，主要记录指定重构方法在书中的页数、重构中文名称、简短概要、被使用情况、简明方法、注意点。

重新组织函数						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
1	Extract Method(110)	提炼函数	将此段代码放进一个独立函数中，并让函数名称解释该函数的用途	一个过长的函数或者一段需要注释才能理解用途的代码，可以将这段代码放进一个独立函数中	提炼代码放到新创建的函数中，处理好变量、参数问题	
2	Inline Method(117)	内联函数	在函数调用点插入函数本体，然后移除该函数	1、被调用函数内的代码简短明了，可以去掉这个函数，直接调用其中的代码。2、有一群组织不甚合理的函数，可以先内联到一个大型函数中，再从中提炼出组织合理的小型函数	1、检查函数，确定它不具多态性。2、将被调用的函数都替换为函数本体	对于递归调用、多返回点、内联至另一个对象中而该对象并无提供访问函数，如有上述情况，则不用此方法。
3	Inline Temp(119)	内联临时变量	将所有对该变量的引用动作，替换为对它赋值的那个表达式自身	某个临时变量被赋予某个函数调用的返回值时，妨碍了其他的重构手法，就应该将它内联化	1、检查给临时变量赋值的语句，确保右边的表达式没有副作用。2、如果这个临时变量并未被声明为final，那就声明为final编译来检查变量是否真的只被赋值一次。3、找到变量的引用点，替换为赋值的那个表达式。4、每次修改后进行测试	
4	Replace Temp with Query(120)	以查询取代临时变量	将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其他函数使用	以一个临时变量保存某一表达式的运算结果。	1、找出那个临时变量。2、将该临时变量声明为final，编译确保变量的确只被赋值一次。3、将“对该临时变量赋值”之语句的等号右侧部分提炼到一个独立函数中。现将函数声明为private，以后再放开也可以。4、测试后使用Inline Temp重构方法。	1、如果final时编译报错，即表示变量不只被赋值一次，我们机u不改进行这项重构。2、我们常常使用临时变量保存循环中的累加信息，我们可以将整个循环都提炼为一个独立函数。
5	Introduce Explaining Variable(124)	引入解释性变量	将复杂的表达式的结果放进一个临时变量，以此变量名称来解释表达式用途	某一表达式非常复杂并且难以阅读	1、声明一个final临时变量，将待分解的复杂表达式中的一部分动作的运算结果赋值给它。2、替换	对于这个重构，我们可以逐渐替换为Extract Method方式，或许更美观一点。前提是此方法的工作量相差不大
6	Split Temporary Variable(128)	分解临时变量	针对每次赋值，创造一个独立、对应的临时变量	某些临时变量被多次赋值。如果临时变量承担多个责任，它就应该被替换(分解)为多个临时变量，每个变量只承担一个责任。	1、将变量名称进行修改。2、声明为final。3、修改相应引用。4、修改后面几次赋值的变量名	
7	Remove Assignments to Parameters(131)	移除对参数的赋值	以一个临时变量取代传入参数的位置	代码对一个参数进行赋值(Java中，不对参数赋值)	1、建立一个临时变量，把待处理的参数赋值予它。2、将后面的引用替换为对这个变量的引用	1、如果传入的参数被赋值后，又被使用，那么要以return方式返回一个值或者对象。2、Java是按值传递的，因此，对于对象参数，我们可以修改参数对象的内部状态，但对参数对象重新赋值是没有意义的。
8	Replace Method with Method Object(135)	以函数对象取代函数	将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后就可以将这个函数分解为多个小型函数	一个大型函数，其中对局部变量的使用使你无法采用Extract Method	1、建立一个新类，根据待处理函数的用途，为这个类命名。2、在新类中建立一个final字段，用以保存原来大型函数所在的对象，同时针对源函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存他们。3、在新类中建立一个构造函数，将大型函数的对象、原来函数的所有参数作为参数。4、创建一个compute()函数，里面装大型函数的所有代码。里面如果需要调用大型函数所在对象的方法，就用传入的参数来调用。5、将旧函数中的函数进行替换：创建新对象，调用compute方法	
9	Substitute Algorithm(139)	替换算法	将函数替换为另一个算法	将某个算法替换为另一个更清晰的算法(例如循环中的多个if判断等)		先将原来的函数分解为较简单的小型函数，然后才进行替换
在对象之间搬移特性						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
10	Move Method(142)	搬移函数	在该函数最常引用的类中建立一个有着类似行为的新函数。经旧函数变成一个单纯的委托函数，或者是完全移除	有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或者被后者调用		当需要使用源类的特性时，有4种选择：1、将这个特性也移到目标类；2、建立或使用一个从目标类到源类的引用关系；3、将源对象当做参数传给目标函数；4、如果所需特性是个变量，将它当作参数传给目标函数。
11	Move Field(146)	搬移字段	在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段	某个字段被其所驻类之外的另一个类更多地用到		
12	Extract Class(149)	提炼类	建立一个新类，将相关的字段和函数从旧类搬移到新类	某各类做了应该由两个类做的事		
13	Inline Class(154)	将类内联化	将这个类的所有特性搬移到另一个类中，然后移除原类	某个类没有做太多事情		
14	Hide Delegate(157)	隐藏“委托关系”	在服务类上建立客户所需的所有函数，用以隐藏委托关系	客户通过一个委托类来调用另一个对象		如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。我们可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来。
15	Remove Middle Man(160)	移除中间人	让客户直接调用受托类	某个类做了过多的简单委托动作		
16	Introduce Foreign Method(162)	引入外加函数	在客户类中建立一个函数，并以第一参数形式传入一个服务类实例	需要为提供服务的类增加一个函数，但是无法修改这个类时(例如类库)		外加函数终归是权宜之计
17	Introduce Local Extension(164)	引入本地扩展	建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类	你需要为服务类提供一些额外函数，但你无法修改这个类		如果增加一两个函数可以直接使用引入外加函数，但是多了的话就需要本地扩展
重新组织数据						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
18	Self Encapsulate Field(171)	自封装字段	给字段设置get/set来存取值	你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙	将字段的引用点替换为相关的函数	有了get、set函数之后，在子类中可以复写上面的方法来达到子类想要的函数运算结果
19	Replace Data Value with Object(175)	以对象取代数据值	把数据项变成对象			简单来说就是将字段封装成对象来运用，此时的对象仅仅是一种值对象
20	Change Value to Reference(179)	将值对象改为引用对象		从一个类衍生出许多彼此相等的实例，我们可以将它们替换为同一个对象		有点混乱
21	Change Reference to Value(183)	将引用对象改为值对象		一个引用对象很小且不可变且不易管理		
22	Replace Array with Object(186)	以对象取代数组				
23	Duplicate Observed Data(189)	复制“被监视数据”				
24	Change Unidirectional Association to Bidirectional(197)	将单项关联改为双向关联		两个类都需要使用对方特性		
25	Change Bidirectional Association to Unidirectional(200)	将双向关联改为单向关联	去掉不必要的关联	两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性		
26	Replace Magic Number with Symbolic Constant(204)	以字面常量取代魔法术	创建一个常量，替换代码中的字面值	有一个字面数值，带有特别含义	static final String MY_BIRTHDAY = "2222/222/22";	如此一来，要更改数值时只需要将常量里的值改变即可。如果这个数是个类型码，可以考虑使用218的方法；如果是个数组的长度，可以在遍历数组时将值改用为Array.length()。
27	Encapsulate Field(206)	封装字段	将public的字段声明为private，并提供get\set方法			面向对象思想，封装即数据隐藏。
28	Encapsulate Collection(208)	封装集合	函数返回一个集合，封装后返回一个只读副本			
29	Replace Record with Data Class(217)	以数据类取代记录		面对传统编程环境中的记录结构		
30	Replace Type code with Class(218)	以类取代类型码	类型码或者枚举值，我们可以创建一个类来进行替换			类型码不会影响宿主类的行为时使用，示例展示出了进行替换之后的可读性增强
31	Replace Type Code with Subclasses(223)	以子类取代类型码				如果类型码会影响宿主类的行为，那么就要以此方法借助多态来处理变化行为
32	Replace Type Code with State/Strategy(227)	以State/Strategy取代类型码		有一个类型码，会影响类的行为，但是无法通过继承手法消除它		
33	Replace Subclass with Fields(232)	以字段取代子类		各个子类的唯一差别只在“返回常量数据”的函数身上，这是就可以返回某个字段，然后销毁子类。		
简化条件表达式						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
34	Decompose Conditional(238)	分解条件表达式	从if\then\else三个段落中分别提炼出独立函数		1、将if段落提炼出来，构成一个独立函数；2、将then段落和else段落都提炼出来，各自构成一个独立函数。	
35	Consolidate Conditional Expression(240)	合并条件表达式	有一系列条件测试，都得到相同的结果，合并之后提炼成一个独立的函数			如果认为这些检查的确彼此独立，的确不应该被视为同一次检查，那么就不要使用本项重构。
36	Consolidate Duplicate Conditional Fragments(243)	合并重复的条件片段	条件表达式的每个分支上有着相同的一段代码			
37	Remove Control Flag(245)	移除控制标记	以break语句或return语句取代控制标记	在一系列布尔表达式中，某个变量带有“控制标记”的作用。		
38	Replace Nested Conditional with Guard Clauses(250)	以卫语句取代嵌套条件表达式		多个if-else嵌套，可以将其变为卫语句，来看清逻辑		
39	Replace Conditional with Polymorphism(255)	以多态取代条件表达式	将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。	条件表达式根据对象类型的不同而选择不同行为		
40	Introduce Null Object(260)	引入Null对象	将null值替换为null对象	需要再三检查某对象是否为null		利用方法的复写，在创建该对象的时候就会判断是否为空，按照结果返回不同的对象。在后面代码的条件判断中，直接调用方法即可。
41	Introduce Assertion(267)	引入断言	以断言明确表现这种假设	某一段代码需要对程序状态做出某种假设		断言false程序会停止运行，只能用它来检查一定必须为真的条件
简化函数调用						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
42	Rename Method(273)	函数改名				
43	Add Parameter(275)	添加参数	添加一个对象参数，让该对象带进函数所需信息			
44	Remove Parameter(277)	移除参数				
45	Separate Querty form Modifier(279)	将查询函数和修改函数分离				
46	Parameterize Method(283)	令函数携带参数	建立单一函数，以参数表达那些不同的值	若干函数做了类似的工作，但在函数本体中却包含了不同的值		
47	Preplace Parameter with Explicit Methods(285)	以明确函数取代参数	针对该参数的每一个可能值，建立一个独立函数	和上面的情况刚好相反，如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为		
48	Preserve Whole Object(288)	保持对象完整	将参数替换为整个对象	从某个对象中去除若干值，将他们作为某一次函数调用时的参数		
49	Replace Parameter with Method(292)	以函数取代参数				首先判断修改接口会造成多严重的后果，然后考虑是否应该降低系统各部分之间的依赖，以减少修改接口所造成的影响。
50	Introduce Parameter Object(295)	引入参数对象		某些参数总是很自然地同时出现		
51	Remove Setting Method(300)	移除设置函数		希望某个字段再对象创建时被设置，然后就不再改变		
52	Hide Method(303)	隐藏函数		将不被调用的函数修改为private		
53	Replace Constructor with Factory Method(304)	以工厂函数取代构造函数	希望在创建对象时不仅仅是做简单的建构动作			
54	Encapsulate Downcast(308)	封装向下转型	将类型转换的步骤放入代码中，转换后再return	返回值Object，需要进行类型转换		在函数中进行类型的转换，可以向用户隐藏一些信息
55	Replace Error Code with Exception(310)	以异常取代错误码	将返回的代码替换为throw的异常	某个函数返回一个特定的代码，用以表示某种错误情况		
56	Replace Exception with Test(315)	以测试取代异常		面对一个调用者可以预先检查的条件，你抛出了一个异常		55、56视情况而定
处理概括关系						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
57	Pull Up Field(320)	字段上移		子类拥有相同的字段，将它上移到父类中		
58	Pull Up Method(322)	函数上移				
59	Pull Up Constructor Body(325)	构造函数本体上移	在超类中新建一个构造函数，并在子类构造函数中调用它	子类拥有一些本体几乎完全一致的构造函数		
60	Push Down Method(328)	函数下移				
61	Push Down Field(329)	字段下移				
62	Extract Subclass(330)	提炼子类		类中的某些特性只被某些实例用到		
63	Extract Superclass(336)	提炼超类				
64	Extract Interface(341)	提炼接口				
65	Collapse Hierarchy(344)	折叠继承体系				简单来说就是子类没有多大用途之后，删除子类
66	From Template Method(345)	塑造模板函数	将这些操作分别放进独立函数中，并保持他们都有相同的签名，于是原函数就变得相同了，然后将原函数上移至超类	有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同		简单来说就是函数中就相同操作步骤，将不同的操作细节提炼出来成一个独立函数，原来函数可以上移到超类，里面操作提炼出来的独立函数名
67	Replace Inheritance with Delegation(352)	以委托取代继承				在子类中新建一个字段，引用超类的一个实例，之后将继承并使用的超类的方法改为该实例的调用，然后就可以去除继承
68	Replace Delegation with Inheritance(355)	以继承取代委托				
大型重构						
	重构名称	重构中文名称	简短概要	被使用情况	简明方法	注意点
69	Tease Apart Inheritance(362)	梳理并分解继承体系	建立两个继承体系，并通过委托关系让其中一个可以调用另一个	某个继承体系同时承担两项责任		
70	Convert Procedural Design to Object(368)	将过程化设计转化为对象设计	将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中	手上有一些传统过程化风格的代码		
71	Separate Domain from Presentation(370)	将领域和表述/显示分离	将领域逻辑分离出来，为它们建立独立的领域类	某些GUI类之中包含了领域逻辑		
72	Extract Hierarchy(375)	提炼继承体系	建立继承体系	某个类做了太多工作，其中一部分工作是以大量条件表达式完成的		
73						
