二、Spring的高级装配
	1. 环境与profile
	不同的环境下，某些配置会进行相应的改变。
	2. 条件化的bean
	希望某个bean只有在特定的条件下才创建。
	3. 处理自动装配的歧义性
	一个借口有三个实现类，都创建了bean交给了spring管理，在注入时注入的是父类接口，此时spring报错，无法精确到准确的bean。解决方案一般有两种：将可选bean中的某一个设为首选的bean；使用限定符来帮助spring将可选的bean的范围缩小到只有一个bean
	4. bean的作用域
	在默认情况下，Spring应用上下文中所有bean都是单例的。Spring定义了多种作用域，可以基于这些作用域创建bean。
======================================================
1、环境与profile
Spring提供了bean profile的功能。
要使用profile，首先要将所有不同的bean定义整理到一个或多个profile中，在将应用部署到每个环境时，要确保对应的profile处于激活(active)的状态。

配置：
	a. Java配置中，在config上注解@Profile("dev")指定为dev环境，它会告诉Spring这个配置类中的bean只有在devprofile激活时才会创建。在Spring3.1中，只能在类级别上使用，在3.2开始，可以用在方法级别上。这样就可以在一个配置类中，写两个环境下的bean。
	b. XML配置中，通过<beans>元素的profile属性，可以声明在文件头里profile="dev"，也可以声明在每一个bean中<bean profile="dev" >…</bean>

激活：
	Spring依赖两个属性来确定profile的激活：spring.profiles.active/spring.profiles.default，如果两者均没有设置值，只会创建没有定义profile的bean。
	两个属性的设置方式：
		作为DispatcherServlet的初始化参数
		作为Web应用的上下文参数
		作为JNDI条目
		作为环境变量
		作为JVM的系统属性
		在集成测试类上，使用@ActiveProfiles("哪种环境")注解设置
======================================================
2、条件化的bean
	Spring4引入了@Conditional注解，用在带有@Bean的方法上，如果注解里的条件结果为true，就会创建这个bean，否则，这个bean就被忽略。
	注解里的条件为一个Class，它指明了条件在指定的类中。
	从Spring4开始，@Profile注解进行了重构，查看源码可以看到，Profile注解上的条件注解有@Conditional(ProfileCondition.class)。说明@Profile本身也是用了@Conditinal注解，并且引用ProfileConditional作为Condition实现，ProfileCondition实现了Condition(后面省略)
======================================================
3、处理自动装配的歧义性
	1. 标示首选的bean
	@Primary注解用在配置bean上，或者在XML配置中bean元素中有primary属性设置为true。
	2. 限定自动装配的bean
	@Qualifier注解用在注入bean上，里面的值输入想要注入的确定的子类。
======================================================
4. bean的作用域
	1. 单例(Singleton)：
	默认，如果要使用其他作用域，需要使用@Scope注解，可以与@Component或@Bean一起使用。里面的属性值为：类.常量 来进行定义。使用XML配置也是使用bean元素的scope属性来设置。
	2. 原型(Prototype)：ConfigurableBeanFactory.SCOPE_PROTOTYPE
	3. 会话(Session)：
	4. 请求(Request)：
	
	1. 使用会话和请求作用域
	购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。
	指定会话作用域：@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES或者TARGET_CLASS)第二个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。
	如果是XML的配置，bean元素中只有scope的属性，对于代理模式的设置，主要在bean元素中添加一个Spring aop命名空间的新元素：<aop:scoped-proxy proxy-target-class="false" />XML的配置是默认的代理类，我们设置后面的属性false，让他生成基于接口的代理。
======================================================
5. 运行时注入
	我们之前学的值得注入都是硬编码，有时候我们希望让这些值在运行时再确定：
		属性占位符(Property placeholder)
			将值声明在一个properties文件中，在Spring的配置类上声明属性源@PropertySource("classpath:/../../…properties")，在类里autowired Environment对象，在进行值得注入时就通过Environment对象调用getProperty()方法来获取properties文件中声明好的值。
			【解析属性占位符】
			Spring一直支持将属性定义到外部的属性文件中，并使用占位符值将其插入到Springbean中，在Spring装配中，占位符的形式为使用"${…}"包装的属性名称。
			在硬编码情况下我们可以使用@Value("${…}")，它的使用方式与@Autowired注解非常相似。
			使用占位符我们必须要配置一个PropertyPlaceholderConfigurer bean或者PropertySourcePlaceholderConfigurer bean(推荐)。
			在XML配置中<context:property-placeholder />
		Spring表达式语言(SpEL)：更为通用。
			特性：使用bean的ID来引用bean；
				  调用方法和访问对象的属性；
				  对值进行算数、关系和逻辑运算；
				  正则表达式匹配；
				  集合操作。
			表达式要放在#{…}里。
			样例：#{T(System).currentTimeMillis()}  它的最终结果是计算表达式的那一刻当前时间的毫秒数。T()将括号里的类视为Java中对应的类型，因此可以调用其static修饰的currentTimeMillis()方法。
			#{sgtPeppers.artist}表示得到ID为sgtPeppers的bean的artist属性。
			#{systemProperties['disc.title']}通过systemProperties对象引用系统属性。
