序列化

当我们的数据存储到Redis的时候，我们的键（kay）和值（value）都是通过spring提供的Serializer序列化到数据库的。

RedisTemplate默认使用的是JdkSerializationRedisSerializer，StringRedisTemplate默认使用的是StringRedisSerializer。

Spring Data JPA为我们提供了下面的Serializer：
	GenericToStringSerializer\Jackson2JsonRedisSerializer\JacksonJsonRedisSerializer\JdkSerializationRedisSerializer(目前最常用)\OxmSerializer\StringRedisSerializer(最轻量级和高效)

我们一般是自己配置RedisTemplate并定义Serializer。

spring-data-redis针对jedis提供了：  连接池自动管理，提供了一个高度封装的"RedisTemplate"类。       将事务操作封装，由容器控制。     针对数据的"序列化/反序列化"，提供了多种可选择策略(RedisSerializer)。

对于RedisTemplate的配置：

	
	


Redis为什么采用序列化方案存对象？
	当一个类实现了Serializable接口，表示该类可以序列化。序列化的目的是将一个实现了Serializable接口的对象转换成一个字节序列，可以把该字节序列保存起来（如保存在一个文件里），以后可以随时将该字节序列恢复为原来的对象。甚至可以将该字节序列放到其他计算机上或者通过网络传输到其他计算机上恢复，只要该计算机平台上存在相应的类就可以正常恢复为原来的对象。
实现： 要序列化一个对象，先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内，再调用writeObject()方法即可序列化一个对象；反序列化也类似。
注意： 使用对象流写入到文件时不仅要保证该对象是序列化的，而且该对象的成员对象也必须是序列化的。

serialversionUID： 主要是为了解决对象反序列化的兼容性问题。如果没有提供，对象序列化后存到硬盘上之后，再增加或减少类的filed。这样，当反序列化时就会出现Exception，造成不兼容问题。但是当serialversionUID相同时，它就会将不一样的field以type的缺省值反序列化，这样就可以避开不兼容问题了。
