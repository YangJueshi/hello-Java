阿里巴巴开发手册阅读笔记

【一、编程规约】
三、代码格式
    9、【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用Windows格式。

四、OOP规约
    1、【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可
    8、【强制】RPC方法的返回值和参数必须使用包装数据类型。
    14、【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。
	说明：
	String str = "a,b,c,,";
	String[] ary = str.split(",");
	// 预期大于3，结果是3
	System.out.println(ary.length);

五、集合处理
    1、【强制】关于hashCode和equals的处理，遵循如下规则： 
	1） 只要重写equals，就必须重写hashCode。 
	2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。 
	3） 如果自定义对象作为Map的键，那么必须重写hashCode和equals。 
	说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。
    2、【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。 
	说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList而是ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。
    3、【强制】在subList场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException 异常。
    7、【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。
    10、【推荐】集合初始化时，指定集合初始值大小。如果暂时无法确定初始值大小，请设置为16（即默认值）。
六、并发处理
七、控制语句
    1、【强制】在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使空代码。
    3、【强制】在高并发场景中，避免使用 ”等于 ”判断作为中或退出的条件。 判断作为中或退出的条件。 
	说明：如果并发控制没有处理好，容易产生等值判断被如果并发控制没有处理好，容易产生等值判断被 “击穿”的情况，使用大于或小区间的情况，使用大于或小区间的情况，使用大于或小区间的情况，使用大于或小区间判断条件来代替。 
	反例：判断剩余奖品数量等于0时，终止发放奖品但因为并处理错误导致数量瞬间变时，终止发放奖品但因为并处理错误导致数量瞬间变时，终止发放奖品但因为并处理错误导致数量瞬间变 成了负数，这样的话，活动无法终止。
八、注释规约
九、其他
    3、【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。
    4、【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。
    7、【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。
【二、异常日志】
看到24页




